if (typeof Namespace === "undefined") {Namespace = {}; Namespace.PATTERN_NAMESPACE_SEPARATOR = /[\\\/\.]/; Namespace.PATTERN_NAMESPACE = /^(?:[\\\/]*[a-z][\w]*)(?:[\\\/\.][a-z][\w]*)*$/i; Namespace.PATTERN_NAMESPACE_SEPARATOR_CONFLICT = /(\..*[\\\/])|(\\.*[\.\/])|(\/.*[\\\.])/; Namespace.using = function(namespace) {if (namespace == null) return null; if (typeof namespace !== "string") throw new TypeError("Invalid namespace: " + typeof namespace); if (!namespace.match(Namespace.PATTERN_NAMESPACE) || namespace.match(Namespace.PATTERN_NAMESPACE_SEPARATOR_CONFLICT)) throw new Error("Invalid namespace" + (namespace.trim() ? ": " + namespace : "")); var scope = window; namespace = namespace.replace(/^[\\\/]/, ""); namespace.split(Namespace.PATTERN_NAMESPACE_SEPARATOR).forEach((entry, index, array) => {if (typeof scope[entry] === "undefined") {scope[entry] = {};} else if (scope[entry] instanceof Object) {} else throw new Error("Invalid namespace: " + array.slice(0, index +1).join(".")); scope = scope[entry];}); return scope;};};
if (Math.uniqueId === undefined) {Math.uniqueId = function(size) {size = size || 16; if (size < 0) sitze = 16; var unique = ""; for (var loop = 0; loop < size; loop++) {var random = Math.floor(Math.random() * Math.floor(26)); if ((Math.floor(Math.random() * Math.floor(26))) % 2 == 0) unique += String(random % 10); else unique += String.fromCharCode(65 +random);} return unique;};};
if (String.prototype.capitalize === undefined) {String.prototype.capitalize = function() {return this.charAt(0).toUpperCase() + this.slice(1);};};
if (String.prototype.encodeHex === undefined) {String.prototype.encodeHex = function() {var text = this; var result = ""; for (var loop = 0; loop < text.length; loop++) {var digit = Number(text.charCodeAt(loop)).toString(16).toUpperCase(); while (digit.length < 2) digit = "0" + digit; result += digit;} return "0x" + result;};};
if (String.prototype.decodeHex === undefined) {String.prototype.decodeHex = function() {var text = this; if (text.match(/^0x/)) text = text.substring(2); var result = ""; for (var loop = 0; loop < text.length; loop += 2) result += String.fromCharCode(parseInt(text.substr(loop, 2), 16)); return result;};};
if (String.prototype.encodeBase64 === undefined) {String.prototype.encodeBase64 = function() {try {return btoa(encodeURIComponent(this).replace(/%([0-9A-F]{2})/g, (match, code) => {return String.fromCharCode("0x" + code);}));} catch (exception) {throw new Error("malformed character sequence");}};};
if (String.prototype.decodeBase64 === undefined) {String.prototype.decodeBase64 = function() {try {return decodeURIComponent(atob(this).split("").map((code) => {return "%" + ("00" + code.charCodeAt(0).toString(16)).slice(-2);}).join(""));} catch (exception) {throw new Error("malformed character sequence");}};};
if (String.prototype.encodeHtml === undefined) {String.prototype.encodeHtml = function() {var element = document.createElement("div"); element.textContent = this; return element.innerHTML;};};
if (String.prototype.hashCode === undefined) {String.prototype.hashCode = function() {if (this.hash == undefined) this.hash = 0; if (this.hash != 0) return this.hash; for (var loop = 0, hops = 0; loop < this.length; loop++) {var temp = 31 *this.hash +this.charCodeAt(loop); if (!Number.isSafeInteger(temp)) {hops++; this.hash = Number.MAX_SAFE_INTEGER -this.hash +this.charCodeAt(loop);} else this.hash = temp;} this.hash = Math.abs(this.hash); this.hash = this.hash.toString(36); this.hash = this.hash.length.toString(36) + this.hash; this.hash = this.hash + hops.toString(36); this.hash = this.hash.toUpperCase(); return this.hash;};};
if (String.prototype.unescape === undefined) {String.prototype.unescape = function() {var text = this; text = text.replace(/\r/g, "\\r"); text = text.replace(/\n/g, "\\n"); text = text.replace(/^(["'])/, "\$1"); text = text.replace(/([^\\])((?:\\{2})*)(?=["'])/g, "$1$2\\"); return eval("\"" + text + "\"");};}; Element.prototype.internalAppendChild = Element.prototype.appendChild; Element.prototype.appendChild = function(node, exclusive) {if (exclusive) this.innerHTML = ""; if (node instanceof Node) {this.internalAppendChild(node);} else if (Array.isArray(node) || node instanceof NodeList || (Symbol && Symbol.iterator && node && typeof node[Symbol.iterator])) {node = Array.from(node); for (var loop = 0; loop < node.length; loop++) this.internalAppendChild(node[loop]);} else this.internalAppendChild(node);};
if (RegExp.quote === undefined) {RegExp.quote = function(text) {if (text == null || text == undefined) return null; return String(text).replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");};};
if (window.serial === undefined) {var timestamp = (new Date().getTime() -946684800000).toString(36); window.serial = Math.uniqueId(10) + (timestamp.length.toString(36) + timestamp).toUpperCase();};
if (window.location.pathcontext === undefined) {window.location.pathcontext = window.location.pathname.replace(/\/([^\/]*\.[^\/]*){0,}$/g, "") || "/";};
if (typeof DataSource === "undefined") {DataSource = {}; DataSource.data; DataSource.locales; DataSource.cache; DataSource.DATA = window.location.pathcontext + "/data"; DataSource.PATTERN_LOCATOR = /^([a-z]+):\/(\/[\w\-\/]+)$/; DataSource.PATTERN_JAVASCRIPT = /^\s*text\s*\/\s*javascript\s*$/i; DataSource.ATTRIBUTE_TYPE = "type"; if (XMLDocument.prototype.clone === undefined) {XMLDocument.prototype.clone = function() {var clone = this.implementation.createDocument(this.namespaceURI, null, null); var node = clone.importNode(this.documentElement, true); clone.appendChild(node); return clone;};}; DataSource.locale; (function() {var locale = (navigator.browserLanguage || navigator.language || "").trim().toLowerCase(); locale = locale.match(/^([a-z]+)/); if (!locale) throw new Error("Locale not available"); DataSource.locale = locale[0]; var request; request = new XMLHttpRequest(); request.open("GET", DataSource.DATA + "/locales.xml", false); request.overrideMimeType("application/xslt+xml"); request.send(); if (request.status == 200) DataSource.data = request.responseXML; if (!DataSource.data && request.status != 404) throw new Error("Locale not available"); DataSource.locales = []; if (!DataSource.data) return; var xml = DataSource.data; var nodes = xml.evaluate("/locales\/*", xml, null, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null); for (var node = nodes.iterateNext(); node; node = nodes.iterateNext()) {var name = node.nodeName.toLowerCase(); DataSource.locales.push(node.nodeName);} locale = DataSource.locale; if (!xml.evaluate("count(/locales/" + locale + ")", xml, null, XPathResult.ANY_TYPE, null).numberValue) locale = xml.evaluate("/locales\/*[@default]", xml, null, XPathResult.ANY_TYPE, null).iterateNext().nodeName.toLowerCase(); if (!locale) throw new Error("Locale not available"); DataSource.locale = locale;})(); DataSource.localize = function(locale) {if (!DataSource.data || !DataSource.locales) throw new Error("Locale not available"); locale = (locale || "").trim().toLowerCase(); if (!locale || !DataSource.locales.includes(locale)) throw new Error("Locale not available"); DataSource.locale = locale;}; DataSource.transform = function(xml, style, raw) {if (typeof xml === "string" && xml.match(DataSource.PATTERN_LOCATOR)) xml = DataSource.fetch(xml); if (typeof style === "string" && style.match(DataSource.PATTERN_LOCATOR)) style = DataSource.fetch(style); if (!(xml instanceof XMLDocument)) throw new TypeError("Invalid xml document"); if (!(style instanceof XMLDocument)) throw new TypeError("Invalid xml stylesheet"); var processor = new XSLTProcessor(); processor.importStylesheet(style); var escape = xml.evaluate("string(\/*/@escape)", xml, null, XPathResult.ANY_TYPE, null).stringValue; escape = !!escape.match(/^yes|on|true|1$/i); var result = processor.transformToDocument(xml); var nodes = result.querySelectorAll(escape ? "*" : "*[escape]"); nodes.forEach((node, index, array) => {if (escape || (node.getAttribute("escape") || "on").match(/^yes|on|true|1$/i)) {var content = node.innerHTML; if (content.indexOf("<") < 0 && content.indexOf(">") < 0) node.innerHTML = node.textContent;} node.removeAttribute("escape");}); var nodes = result.querySelectorAll("script[type],script:not([type])"); nodes.forEach((node, index, array) => {if (!node.hasAttribute(DataSource.ATTRIBUTE_TYPE) || (node.getAttribute(DataSource.ATTRIBUTE_TYPE) || "").match(DataSource.PATTERN_JAVASCRIPT)) node.setAttribute("type", "composite/javascript");}); if (arguments.length > 2 && !!raw) return result; if (result.body) return result.body.childNodes; if (result.firstChild && result.firstChild.nodeName.match(/^transformiix\b/i)) return result.firstChild.childNodes; return result.childNodes;}; DataSource.fetch = function(locator, transform, raw) {if (typeof locator !== "string" || !locator.match(DataSource.PATTERN_LOCATOR)) throw new Error("Invalid locator: " + String(locator)); var type = locator.match(DataSource.PATTERN_LOCATOR)[1]; var path = locator.match(DataSource.PATTERN_LOCATOR)[2]; if (arguments.length == 1) {DataSource.cache = DataSource.cache || {}; var data = DataSource.DATA + "/" + DataSource.locale + "/" + path + "." + type; data = data.replace(/\/+/g, "/"); hash = data.hashCode(); if (DataSource.cache.hasOwnProperty(hash)) return DataSource.cache[hash]; var request = new XMLHttpRequest(); request.open("GET", data, false); request.overrideMimeType("application/xslt+xml"); request.send(); if (request.status != 200) throw new Error("HTTP status " + request.status + " for " + request.responseURL); data = request.responseXML; DataSource.cache[hash] = data; return data;} if (!type.match(/^xml$/) && transform) throw new Error("Transformation is not supported for this locator"); var data = DataSource.fetch(locator); if (!transform) return data.clone(); var style = DataSource.fetch(locator.replace(/^[a-z]+/i, "xslt")); return DataSource.transform(data, style, raw);}; DataSource.collect = function(locators) {if (arguments.length <= 0) return null; var collection = []; var collector = "collection"; if (arguments.length == 2 && typeof arguments[0] === "string" && Array.isArray(arguments[1])) {if (!arguments[0].match(/[a-z]\w+/i)) throw new TypeError("Invalid collector"); collector = arguments[0]; collection = collection.concat(arguments[1]);} else if (arguments.length == 1 && Array.isArray(arguments[0])) {collection = collection.concat(arguments[0]);} else {for (var loop = 0; loop < arguments.length; loop++) collection.push(arguments[loop]);} DataSource.cache = DataSource.cache || {}; var hash = collection.join().hashCode(); collection.forEach((entry, index, array) => {hash += ":" + String(entry).hashCode();}); if (DataSource.cache.hasOwnProperty(hash)) return DataSource.cache[hash].clone(); var root = document.implementation.createDocument(null, collector, null, null); collection.forEach((entry, index, array) => {if (typeof entry !== "string") throw TypeError("Invalid collection entry"); root.documentElement.appendChild(DataSource.fetch(entry).documentElement.cloneNode(true));}); DataSource.cache[hash] = root; return root.clone();};};
if (typeof Messages === "undefined") {Messages = {}; (function() {var localize = DataSource.localize; DataSource.localize = function(locale) {for (var property in Messages) if (typeof Messages[property] == "string") delete Messages[property]; DataSource.localize.internal(locale); var xpath = "/locales/" + DataSource.locale + "/label"; var label = DataSource.data.evaluate(xpath, DataSource.data, null, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null); for (var node = label.iterateNext(); node; node = label.iterateNext()) {var key = (node.getAttribute("key") || "").trim(); if (key == "") continue; var value = ((node.getAttribute("value") || "").trim() + " " + (node.textContent).trim()).trim(); value = value.unescape(); Messages[key] = value;}}; DataSource.localize.internal = localize; if (DataSource.data && DataSource.locale && DataSource.locales && DataSource.locales.includes(DataSource.locale)) DataSource.localize(DataSource.locale);})();};
if (typeof Composite === "undefined") {Composite = {}; Composite.macros; Composite.selectors; Composite.acceptors; Composite.listeners; Composite.models; Composite.MODULES = window.location.pathcontext + "/modules"; Composite.ATTRIBUTE_COMPOSITE = "composite"; Composite.ATTRIBUTE_CONDITION = "condition"; Composite.ATTRIBUTE_EVENTS = "events"; Composite.ATTRIBUTE_ID = "id"; Composite.ATTRIBUTE_IMPORT = "import"; Composite.ATTRIBUTE_INTERVAL = "interval"; Composite.ATTRIBUTE_ITERATE = "iterate"; Composite.ATTRIBUTE_NAME = "name"; Composite.ATTRIBUTE_OUTPUT = "output"; Composite.ATTRIBUTE_RENDER = "render"; Composite.ATTRIBUTE_TEXT = "text"; Composite.ATTRIBUTE_TYPE = "type"; Composite.ATTRIBUTE_VALIDATE = "validate"; Composite.ATTRIBUTE_VALUE = "value"; Composite.PATTERN_ATTRIBUTE_ACCEPT = /^composite|condition|events|id|import|interval|iterate|output|render|validate$/i; Composite.PATTERN_ATTRIBUTE_STATIC = /^composite|id$/i; Composite.PATTERN_EXPRESSION_CONTAINS = /\{\{((?:(?:.*?[^\\](?:\\\\)*)|(?:(?:\\\\)*))*?)\}\}/g; Composite.PATTERN_EXPRESSION_EXCLUSIVE = /^\s*\{\{((?:(?:.*?[^\\](?:\\\\)*)|(?:(?:\\\\)*))*?)\}\}\s*(.*)$/; Composite.PATTERN_EXPRESSION_VARIABLE = /^\s*(_*[a-z]\w*)\s*:\s*(.*?)\s*$/i; Composite.PATTERN_ELEMENT_IGNORE = /script|style/i; Composite.PATTERN_SCRIPT = /script/i; Composite.PATTERN_COMPOSITE_SCRIPT = /^composite\/javascript$/i; Composite.PATTERN_COMPOSITE_ID = /^(?:[a-z]\w*)*$/i; Composite.PATTERN_ELEMENT_ID = /^(?:((?:[a-z]\w*)(?:\.(?:[a-z]\w*))*)\.)*([a-z]\w*)(?:\:(\w*))*$/i; Composite.PATTERN_CUSTOMIZE_SCOPE = /^[a-z](?:(?:\w*)|([\-\w]*\w))$/i; Composite.PATTERN_DATASOURCE_URL = /^\s*xml:\s*(\/[^\s]+)\s*(?:\s*(?:xslt|xsl):\s*(\/[^\s]+))*$/i; Composite.PATTERN_EVENT = /^([A-Z][a-z]+)+$/; Composite.EVENT_RENDER_START = "RenderStart"; Composite.EVENT_RENDER_NEXT = "RenderNext"; Composite.EVENT_RENDER_END = "RenderEnd"; Composite.EVENT_SCAN_START = "ScanStart"; Composite.EVENT_SCAN_NEXT = "ScanNext"; Composite.EVENT_SCAN_END = "ScanEnd"; Composite.EVENT_MOUNT_START = "MountStart"; Composite.EVENT_MOUNT_NEXT = "MountNext"; Composite.EVENT_MOUNT_END = "MountEnd"; Composite.EVENT_AJAX_START = "AjaxStart"; Composite.EVENT_AJAX_PROGRESS = "AjaxProgress"; Composite.EVENT_AJAX_RECEIVE = "AjaxReceive"; Composite.EVENT_AJAX_LOAD = "AjaxLoad"; Composite.EVENT_AJAX_ABORT = "AjaxAbort"; Composite.EVENT_AJAX_TIMEOUT = "AjaxTimeout"; Composite.EVENT_AJAX_ERROR = "AjaxError"; Composite.EVENT_AJAX_END = "AjaxEnd"; Composite.EVENT_ERROR = "Error"; Composite.events = "abort after|print animation|end animation|iteration animation|start" + " before|print before|unload blur" + " can|play can|play|through change click context|menu copy cut" + " dbl|click drag drag|end drag|enter drag|leave drag|over drag|start drop duration|change" + " ended error" + " focus focus|in focus|out" + " hash|change" + " input invalid" + " key|down key|press key|up" + " load loaded|data loaded|meta|data load|start" + " message mouse|down mouse|enter mouse|leave mouse|move mouse|over mouse|out mouse|up mouse|wheel" + " offline online open" + " page|hide page|show paste pause play playing popstate progress" + " rate|change resize reset" + " scroll search seeked seeking select show stalled storage submit suspend" + " time|update toggle touch|cancel touch|end touch|move touch|start transition|end" + " unload" + " volume|change" + " waiting wheel"; Composite.PATTERN_EVENT_FUNCTIONS = (function() {var pattern = Composite.events.replace(/(?:\||\b)(\w)/g, (match, letter) => {return letter.toUpperCase();}); pattern = new RegExp("^on(" + pattern.replace(/\s+/g, "|") + ")"); return pattern;})(); Composite.lock = function(context, selector) {context.queue = context.queue || []; if (context.lock === undefined || context.lock === false) {context.lock = {ticks:1, selector:selector, queue:[], share:function() {this.ticks++; return this;}, release:function() {this.ticks--; if (this.ticks > 0) return; context.lock = false; if (context == Composite.render) {Composite.fire(Composite.EVENT_RENDER_END, this.selector); Composite.scan(this.selector);} else if (context == Composite.mount) {Composite.fire(Composite.EVENT_MOUNT_END, this.selector);} else if (context == Composite.scan) {Composite.fire(Composite.EVENT_SCAN_END, this.selector);} else throw new Error("Invalid context: " + context); var selector = context.queue.shift(); if (selector) context.call(null, selector);}}; if (context == Composite.render) Composite.fire(Composite.EVENT_RENDER_START, this.selector); else if (context == Composite.mount) Composite.fire(Composite.EVENT_MOUNT_START, this.selector); else if (context == Composite.scan) Composite.fire(Composite.EVENT_SCAN_START, this.selector); else throw new Error("Invalid context: " + context);} else {if (context == Composite.render) Composite.fire(Composite.EVENT_RENDER_NEXT, this.selector); else if (context == Composite.mount) Composite.fire(Composite.EVENT_MOUNT_NEXT, this.selector); else if (context == Composite.scan) Composite.fire(Composite.EVENT_SCAN_NEXT, this.selector); else throw new Error("Invalid context: " + context);} return context.lock;}; if (Object.indication === undefined) Object.indication = 0; if (Object.prototype.ordinal === undefined) {Object.prototype.ordinal = function() {this.serial = this.serial || ++Object.indication; return this.serial;};}; if (Object.lookup === undefined) Object.lookup = function(namespace) {namespace = (namespace || "").trim().split(/\./); if (!namespace || namespace.length <= 0) return null; var scope = window; for (var index = 0; scope && index < namespace.length; index++) {if (namespace[index] in scope && scope[namespace[index]] instanceof Object) scope = scope[namespace[index]]; else return null;} return scope;}; if (Object.exists === undefined) Object.exists = function(namespace) {return Object.lookup(namespace) != null;}; XMLHttpRequest.prototype.internalOpen = XMLHttpRequest.prototype.open; XMLHttpRequest.prototype.open = function(variants) {var callback = function() {if (arguments.length > 0) {var event = arguments[0]; if (event.type == "loadstart") event = Composite.EVENT_AJAX_START; else if (event.type == "progress") event = Composite.EVENT_AJAX_PROGRESS; else if (event.type == "readystatechange") event = Composite.EVENT_AJAX_RECEIVE; else if (event.type == "load") event = Composite.EVENT_AJAX_LOAD; else if (event.type == "abort") event = Composite.EVENT_AJAX_ABORT; else if (event.type == "error") event = Composite.EVENT_AJAX_ERROR; else if (event.type == "timeout") event = Composite.EVENT_AJAX_TIMEOUT; else if (event.type == "loadend") event = Composite.EVENT_AJAX_END; else return; Composite.fire(event, arguments[0]);}}; if (typeof this.internalInit === "undefined") {this.internalInit = true; this.addEventListener("loadstart", callback); this.addEventListener("progress", callback); this.addEventListener("readystatechange", callback); this.addEventListener("load", callback); this.addEventListener("abort", callback); this.addEventListener("error", callback); this.addEventListener("timeout", callback); this.addEventListener("loadend", callback);} this.internalOpen.apply(this, arguments);}; Composite.listen = function(event, callback) {if (typeof event !== "string") throw new TypeError("Invalid event: " + typeof event); if (typeof callback !== "function" && callback !== null && callback !== undefined) throw new TypeError("Invalid callback: " + typeof callback); if (!event.match(Composite.PATTERN_EVENT)) throw new Error("Invalid event" + (event.trim() ? ": " + event : "")); event = event.toLowerCase(); Composite.listeners = Composite.listeners || []; if (!Array.isArray(Composite.listeners[event])) Composite.listeners[event] = []; Composite.listeners[event].push(callback);}; Composite.fire = function(event, variants) {event = (event || "").trim(); if (!Composite.listeners || !event) return; var listeners = Composite.listeners[event.toLowerCase()]; if (!Array.isArray(listeners)) return; variants = Array.from(arguments); variants = variants.slice(1); variants.unshift(event); listeners.forEach((callback, index, array) => {callback.apply(null, variants);});}; Composite.asynchron = function(task, variants) {arguments = Array.from(arguments); arguments = arguments.slice(2); window.setTimeout((invoke, variants) => {invoke.apply(null, variants);}, 0, task, arguments);}; Composite.mount = function(selector, lock) {Composite.mount.queue = Composite.mount.queue || []; if (Composite.mount.lock && Composite.mount.lock != lock) {if (!Composite.mount.queue.includes(selector)) Composite.mount.queue.push(selector); return;} var lock = Composite.lock(Composite.mount, selector); try {if (typeof selector === "string") {selector = selector.trim(); if (!selector) return; var nodes = document.querySelectorAll(selector); nodes.forEach((node, index, array) => {Composite.mount(node, lock.share());}); return;} if (!(selector instanceof Element)) return; var model = Composite.mount.lookup(selector); if (!(model instanceof Object) || model instanceof Element) return; if (Composite.mount.queue.includes(selector)) return; var serial = selector.ordinal(); var object = Composite.render.meta[serial] || {}; var events = object.events || {}; model = model.scope[model.property]; for (var entry in model) if (typeof model[entry] === "function" && entry.match(Composite.PATTERN_EVENT_FUNCTIONS) && typeof events[entry.substring(2).toLowerCase()] !== "function") selector.addEventListener(entry.substring(2).toLowerCase(), model[entry]);} finally {lock.release();}}; Composite.mount.locate = function(element) {if (!(element instanceof Element)) return null; var serial = (element.getAttribute(Composite.ATTRIBUTE_ID) || "").trim(); if (element.hasAttribute(Composite.ATTRIBUTE_COMPOSITE)) {if (!serial.match(Composite.PATTERN_COMPOSITE_ID)) throw new Error("Invalid composite id" + (serial ? ": " + serial : "")); if (!Object.lookup(serial)) return null; return {composite:serial, model:serial, property:null, name:null};} var meta = serial.match(Composite.PATTERN_ELEMENT_ID); if (!meta) return null; meta = {composite:null, model:meta[1], property:meta[2], name:meta[3]}; for (var scope = element; scope; scope = scope.parentNode) {if (!(scope instanceof Element) || !scope.hasAttribute(Composite.ATTRIBUTE_COMPOSITE)) continue; var serial = (scope.getAttribute(Composite.ATTRIBUTE_ID) || "").trim(); if (!serial.match(Composite.PATTERN_COMPOSITE_ID)) throw new Error("Invalid composite id" + (serial ? ": " + serial : "")); serial = serial.replace(/:.*$/, ""); if (meta.composite) meta.composite = "." + meta.composite; meta.composite = serial + (meta.composite || "");} if (meta.composite && !Object.lookup(meta.composite)) return null; if (meta.model) {if (meta.composite) {var scope = Object.lookup(meta.composite + "." + meta.model); if (scope && scope.hasOwnProperty(meta.property)) {meta.model = meta.composite + "." + meta.model; return meta;}} var scope = Object.lookup(meta.model); if (scope && scope.hasOwnProperty(meta.property)) return meta; return null;} if (!meta.composite) return null; meta.model = meta.composite; var scope = Object.lookup(meta.model); if (scope && scope.hasOwnProperty(meta.property)) return meta; return null;}; Composite.mount.lookup = function(element) {if (!(element instanceof Element) || !element.hasAttribute(Composite.ATTRIBUTE_ID)) return null; var serial = (element.getAttribute(Composite.ATTRIBUTE_ID) || "").trim(); if (element.hasAttribute(Composite.ATTRIBUTE_COMPOSITE)) serial = serial.match(Composite.PATTERN_COMPOSITE_ID); else serial = serial.match(Composite.PATTERN_ELEMENT_ID); if (!serial) throw new Error("Invalid composite id" + (serial ? ": " + serial : "")); var meta = Composite.mount.locate(element); if (!meta) return null; scope = Object.lookup(meta.model); if (!scope) return null; if (element.hasAttribute(Composite.ATTRIBUTE_COMPOSITE)) return {scope:scope, model:meta.model}; return {composite:{scope:scope, model:meta.model}, scope:scope, model:meta.model, property:meta.property, name:meta.name};}; Composite.scan = function(selector, lock) {Composite.scan.queue = Composite.scan.queue || []; if (Composite.scan.lock && Composite.scan.lock != lock) {if (!Composite.scan.queue.includes(selector)) Composite.scan.queue.push(selector); return;} var lock = Composite.lock(Composite.scan, selector); try {if (typeof selector === "string") {selector = selector.trim(); if (!selector) return; var nodes = document.querySelectorAll(selector); nodes.forEach((node, index, array) => {Composite.scan(node, lock.share());}); return;} if (!(selector instanceof Element)) return; var nodes = selector.querySelectorAll("[" + Composite.ATTRIBUTE_ID + "]"); nodes = Array.from(nodes); if (!selector.hasAttribute(Composite.ATTRIBUTE_MOUNT)) nodes.unshift(selector); nodes.forEach((node, index, array) => {var serial = (node.getAttribute(Composite.ATTRIBUTE_ID) || "").trim(); if (serial.match(Composite.PATTERN_ELEMENT_ID)) Composite.mount(node);});} finally {lock.release();}}; Composite.customize = function(scope, callback) {if (typeof scope === "function" && arguments.length == 1) {Composite.acceptors = Composite.acceptors || []; Composite.acceptors.push(scope); return;} if (typeof scope !== "string") throw new TypeError("Invalid scope: " + typeof scope); if (typeof callback !== "function" && callback !== null && callback !== undefined) throw new TypeError("Invalid callback: " + typeof callback); scope = scope.trim(); if (scope.length <= 0) throw new Error("Invalid scope"); if (scope.match(Composite.PATTERN_CUSTOMIZE_SCOPE)) {Composite.macros = Composite.macros || {}; if (callback == null) delete Composite.macros[scope.toLowerCase()]; else Composite.macros[scope.toLowerCase()] = callback;} else {var hash = scope.toLowerCase().hashCode(); Composite.selectors = Composite.selectors || {}; if (callback == null) delete Composite.selectors[hash]; else Composite.selectors[hash] = {selector:scope, callback:callback};}}; Composite.render = function(selector, lock) {if (!selector) return; Composite.render.queue = Composite.render.queue || []; if (Composite.render.lock && Composite.render.lock != lock) {if (!Composite.render.queue.includes(selector)) Composite.render.queue.push(selector); return;} var lock = Composite.lock(Composite.render, selector); try {if (typeof selector === "string") {selector = selector.trim(); if (!selector) return; var nodes = document.querySelectorAll(selector); nodes.forEach((node, index, array) => {Composite.render(node, lock.share());}); return;} if (!(selector instanceof Node)) return; Composite.macros = Composite.macros || {}; var macro = Composite.macros[selector.nodeName.toLowerCase()]; if (macro && macro(selector) === false) return; Composite.selectors = Composite.selectors || {}; if (selector.parentNode) {for (var macro in Composite.selectors) {macro = Composite.selectors[macro]; var nodes = selector.parentNode.querySelectorAll(macro.selector); if (Array.from(nodes).includes(selector)) {if (macro.callback(selector) === false) return;}}} Composite.render.meta = Composite.render.meta || []; var serial = selector.ordinal(); var object = Composite.render.meta[serial]; if (!object) {Composite.acceptors = Composite.acceptors || []; Composite.acceptors.forEach((acceptor, index, array) => {acceptor.call(null, selector);}); object = {serial:serial, element:selector, attributes:{}}; Composite.render.meta[serial] = object; if ((selector instanceof Element) && selector.attributes) {Array.from(selector.attributes).forEach((attribute, index, array) => {var value = (attribute.value || "").trim(); if (value.match(Composite.PATTERN_EXPRESSION_CONTAINS) || attribute.name.match(Composite.PATTERN_ATTRIBUTE_ACCEPT)) {if (attribute.name.match(Composite.PATTERN_ATTRIBUTE_ACCEPT) && !attribute.name.match(Composite.PATTERN_ATTRIBUTE_STATIC)) selector.removeAttribute(attribute.name); object.attributes[attribute.name.toLowerCase()] = value;}}); if (object.attributes.hasOwnProperty(Composite.ATTRIBUTE_COMPOSITE)) Composite.render.include(selector); var condition = object.attributes.hasOwnProperty(Composite.ATTRIBUTE_CONDITION) ? object.attributes[Composite.ATTRIBUTE_CONDITION] : null; delete object.attributes[Composite.ATTRIBUTE_CONDITION]; if (condition) {delete object.attributes[Composite.ATTRIBUTE_CONDITION]; var placeholder = document.createTextNode(""); object = {serial:placeholder.ordinal(), element:placeholder, attributes:object.attributes, condition:condition, template:selector.cloneNode(true), output:null}; Composite.render.meta[object.serial] = object; delete Composite.render.meta[serial]; selector.parentNode.replaceChild(placeholder, selector); selector = placeholder; serial = selector.ordinal(); object = Composite.render.meta[serial];}}} if (object.hasOwnProperty("placeholder")) {selector = object.placeholder.element; serial = selector.ordinal(); object = Composite.render.meta[serial];} if (selector.nodeType == Node.TEXT_NODE && !object.hasOwnProperty(Composite.ATTRIBUTE_CONDITION)) {if (selector.parentNode && selector.parentNode.nodeName.match(Composite.PATTERN_ELEMENT_IGNORE)) return; if (object.attributes.hasOwnProperty(Composite.ATTRIBUTE_TEXT)) return; if (object.attributes.hasOwnProperty(Composite.ATTRIBUTE_VALUE)) {object.render(); return;} var content = selector.textContent; if (content.match(Composite.PATTERN_EXPRESSION_CONTAINS)) {content = content.replace(Composite.PATTERN_EXPRESSION_CONTAINS, (match, offset, content) => {match = match.substring(2, match.length -2).trim(); if (!match) return ""; var node = document.createTextNode(""); var serial = node.ordinal(); var object = {serial:serial, element:node, attributes:{}, value:null, render:function() {if (this.attributes.hasOwnProperty(Composite.ATTRIBUTE_NAME)) {var name = (this.attributes[Composite.ATTRIBUTE_NAME] || "").trim(); var value = (this.attributes[Composite.ATTRIBUTE_VALUE] || "").trim(); window[name] = Expression.eval(this.serial + ":" + Composite.ATTRIBUTE_VALUE, value); word = "";} else {word = this.attributes[Composite.ATTRIBUTE_VALUE]; word = Expression.eval(this.serial + ":" + Composite.ATTRIBUTE_VALUE, word);} this.value = word; this.element.textContent = word;}}; var param = match.match(Composite.PATTERN_EXPRESSION_VARIABLE); if (param) {object.attributes[Composite.ATTRIBUTE_NAME] = param[1]; object.attributes[Composite.ATTRIBUTE_VALUE] = "{{" + param[2] + "}}";} else object.attributes[Composite.ATTRIBUTE_VALUE] = "{{" + match + "}}"; Composite.render.meta[serial] = object; return "{{" + serial + "}}";}); if (content.match(Composite.PATTERN_EXPRESSION_CONTAINS)) {var words = content.split(/(\{\{\d+\}\})/); words.forEach((word, index, array) => {if (word.match(/^\{\{\d+\}\}$/)) {var serial = parseInt(word.substring(2, word.length -2).trim()); var object = Composite.render.meta[serial]; object.render();} else {var node = document.createTextNode(word); var serial = node.ordinal(); var object = {serial:serial, element:node, attributes:{}}; object.element.textContent = word; object.attributes[Composite.ATTRIBUTE_TEXT] = word; Composite.render.meta[serial] = object;} array[index] = object.element;}); if (selector.parentNode == null) return; words.forEach((node, index, array) => {selector.parentNode.insertBefore(node, selector);}); selector.parentNode.removeChild(selector); return;} selector.nodeValue = content;} object.attributes[Composite.ATTRIBUTE_TEXT] = content; return;} var dock = function(object) {Composite.models = Composite.models || []; if (!object.attributes.hasOwnProperty(Composite.ATTRIBUTE_COMPOSITE) || !object.attributes.hasOwnProperty(Composite.ATTRIBUTE_ID) || Composite.models.includes(object.attributes[Composite.ATTRIBUTE_ID])) return; Composite.models.push(object.attributes[Composite.ATTRIBUTE_ID]); var meta = Composite.mount.lookup(object.template || object.element); if (meta && meta.model && meta.scope && typeof meta.scope.dock === "function") meta.scope.dock.call(null);}; if (object.attributes.hasOwnProperty(Composite.ATTRIBUTE_COMPOSITE) && !object.attributes.hasOwnProperty(Composite.ATTRIBUTE_CONDITION) && !object.hasOwnProperty(Composite.ATTRIBUTE_CONDITION)) dock(object); if (selector.nodeType == Node.TEXT_NODE && object.hasOwnProperty(Composite.ATTRIBUTE_CONDITION)) {var placeholder = object; if (Expression.eval(serial + ":" + Composite.ATTRIBUTE_CONDITION, placeholder.condition) === true) {if (object.attributes.hasOwnProperty(Composite.ATTRIBUTE_COMPOSITE)) dock(object); if (!placeholder.output || !document.body.contains(placeholder.output)) {var template = placeholder.template.cloneNode(true); placeholder.output = template; var serial = template.ordinal(); var object = {serial:serial, element:template, attributes:object.attributes, lock:true}; Composite.render.meta[serial] = object; Composite.render(template, lock.share()); object.placeholder = placeholder; selector.parentNode.insertBefore(template, selector); return;} selector = placeholder.output; serial = selector.ordinal(); object = Composite.render.meta[serial];} else {if (!placeholder.output) return; selector.parentNode.removeChild(placeholder.output); delete placeholder.output; return;}} if (!(selector instanceof Element)) return; var events = object.attributes.hasOwnProperty(Composite.ATTRIBUTE_EVENTS) ? object.attributes[Composite.ATTRIBUTE_EVENTS] : null; delete object.attributes[Composite.ATTRIBUTE_EVENTS]; var render = object.attributes.hasOwnProperty(Composite.ATTRIBUTE_RENDER) ? object.attributes[Composite.ATTRIBUTE_RENDER] : false; delete object.attributes[Composite.ATTRIBUTE_RENDER]; if (events) {events = events.split(/\s+/); events.forEach((event, index, array) => {var meta = Composite.mount.lookup(selector); if (meta && meta.scope && meta.property && typeof meta.scope[meta.property] === "object" && meta.scope[meta.property] != null) {var invoke = "on" + event.capitalize(); if (invoke.match(Composite.PATTERN_EVENT_FUNCTIONS)) {if (typeof meta.scope[meta.property][invoke] === "function") {object.events = object.events || {}; object.events[event.toLowerCase()] = meta.scope[meta.property][invoke];}}} selector.addEventListener(event.toLowerCase(), (event) => {var target = event.currentTarget; var serial = target.ordinal(); var object = Composite.render.meta[serial]; if (!target.nodeName.match(Composite.PATTERN_ELEMENT_IGNORE) && Composite.ATTRIBUTE_VALUE in target && typeof target[Composite.ATTRIBUTE_VALUE] !== "function") {var meta = Composite.mount.lookup(target); if (meta) {var valid = false; if (object.attributes.hasOwnProperty(Composite.ATTRIBUTE_VALIDATE) && typeof meta.scope[Composite.ATTRIBUTE_VALIDATE] === "function") {valid = meta.scope[Composite.ATTRIBUTE_VALIDATE].call(null, target, target.value) === true;} else valid = true; if (valid) {if (meta.scope[meta.property] instanceof Object) meta.scope[meta.property].value = target.value; else meta.scope[meta.property] = target.value}}} var events = object.events || {}; if (typeof events[event.type] === "function") events[event.type].call(null, event); if (render) {if ((render || "").match(Composite.PATTERN_EXPRESSION_CONTAINS)) render = Expression.eval(serial + ":" + Composite.ATTRIBUTE_RENDER, render); Composite.render(render, lock.share());}});});} if (object.attributes.hasOwnProperty(Composite.ATTRIBUTE_IMPORT)) {selector.innerHTML = ""; var value = object.attributes[Composite.ATTRIBUTE_IMPORT]; if ((value || "").match(Composite.PATTERN_EXPRESSION_CONTAINS)) value = Expression.eval(serial + ":" + Composite.ATTRIBUTE_IMPORT, value); Composite.render.cache = Composite.render.cache || {}; if (!value) {if (!object.lock) delete object.attributes[Composite.ATTRIBUTE_IMPORT];} else if (value instanceof Element || value instanceof NodeList) {selector.appendChild(value, true); if (!object.lock) delete object.attributes[Composite.ATTRIBUTE_IMPORT];} else if (String(value).match(Composite.PATTERN_DATASOURCE_URL)) {var data = String(value).match(Composite.PATTERN_DATASOURCE_URL); data[2] = DataSource.fetch("xslt:\/\/" + (data[2] || data[1])); data[1] = DataSource.fetch("xml:\/\/" + data[1]); data = DataSource.transform(data[1], data[2]); selector.appendChild(data, true); var serial = selector.ordinal(); var object = Composite.render.meta[serial]; if (!object.lock) delete object.attributes[Composite.ATTRIBUTE_IMPORT];} else if (typeof Composite.render.cache[value] !== "undefined") {selector.innerHTML = Composite.render.cache[value]; var serial = selector.ordinal(); var object = Composite.render.meta[serial]; if (!object.lock) delete object.attributes[Composite.ATTRIBUTE_IMPORT];} else {window.setTimeout((selector, lock, url) => {try {var request = new XMLHttpRequest(); request.overrideMimeType("text/plain"); request.open("GET", url, false); request.send(); if (request.status != "200") throw Error("HTTP status " + request.status + " for " + url); Composite.render.cache[url] = request.responseText; selector.innerHTML = request.responseText; var serial = selector.ordinal(); var object = Composite.render.meta[serial]; if (!object.lock) delete object.attributes[Composite.ATTRIBUTE_IMPORT];} catch (error) {Composite.fire(Composite.EVENT_AJAX_ERROR, error); throw error;} finally {lock.release();}}, 0, selector, lock.share(), value);}} if (object.attributes.hasOwnProperty(Composite.ATTRIBUTE_OUTPUT)) {selector.innerHTML = ""; var value = object.attributes[Composite.ATTRIBUTE_OUTPUT]; if ((value || "").match(Composite.PATTERN_EXPRESSION_CONTAINS)) value = Expression.eval(serial + ":" + Composite.ATTRIBUTE_OUTPUT, value); if (String(value).match(Composite.PATTERN_DATASOURCE_URL)) {var data = String(value).match(Composite.PATTERN_DATASOURCE_URL); data[2] = DataSource.fetch("xslt:\/\/" + (data[2] || data[1])); data[1] = DataSource.fetch("xml:\/\/" + data[1]); data = DataSource.transform(data[1], data[2]); selector.appendChild(data, true);} else if (value instanceof Node) selector.appendChild(value.cloneNode(true), true); else if (value instanceof NodeList) Array.from(value).forEach(function(node, index, array) {selector.appendChild(node.cloneNode(true), index == 0);}); else selector.innerHTML = String(value);} var interval = object.attributes[Composite.ATTRIBUTE_INTERVAL]; if (interval && !object.interval) {interval = String(interval).trim(); var context = serial + ":" + Composite.ATTRIBUTE_INTERVAL; interval = String(Expression.eval(context, interval)); if (interval.match(/^\d+$/)) {if (object.hasOwnProperty("placeholder")) {object = object.placeholder; selector = object.element;} interval = parseInt(interval); object.interval = {object:object, selector:selector, task:function(interval) {var serial = interval.selector.ordinal(); var object = Composite.render.meta[serial]; var interrupt = !document.body.contains(interval.selector); if (!object) interrupt = true; if (object && object.hasOwnProperty(Composite.ATTRIBUTE_CONDITION) && (!object.condition.element || !document.body.contains(object.condition.element))) interrupt = true; if (interrupt) {window.clearInterval(interval.timer); delete interval.object.interval} else Composite.render(interval.selector);}}; object.interval.timer = window.setInterval(object.interval.task, interval, object.interval);} else if (interval) console.error("Invalid interval: " + interval);} if (object.attributes.hasOwnProperty(Composite.ATTRIBUTE_ITERATE)) {if (!object.iterate) {var iterate = object.attributes[Composite.ATTRIBUTE_ITERATE]; var content = iterate.match(Composite.PATTERN_EXPRESSION_EXCLUSIVE); content = content && !content[2] ? content[1].match(Composite.PATTERN_EXPRESSION_VARIABLE)  : null; if (content) {object.iterate = {name:content[1].trim(), expression:"{{" + content[2].trim() + "}}"}; object.template = selector.cloneNode(true);} else console.error("Invalid iterate: " + iterate);} if (object.iterate) {var variable = window[object.iterate.name]; try {var context = serial + ":" + Composite.ATTRIBUTE_ITERATE; selector.innerHTML = ""; iterate = Expression.eval(context, object.iterate.expression); if (iterate) {iterate = Array.from(iterate); iterate.forEach((item, index, array) => {window[object.iterate.name] = {item:item, index:index, data:array}; var template = object.template.cloneNode(true); Composite.render(template, lock.share()); selector.appendChild(template.childNodes); delete Composite.render.meta[template.ordinal()];});}} finally {delete window[object.iterate.name]; if (variable !== undefined) window[object.iterate.name] = variable;} return;}} if (!selector.nodeName.match(Composite.PATTERN_ELEMENT_IGNORE)) {var attributes = Array.from(selector.attributes || []); attributes = attributes.map(entry => entry.name); attributes = attributes.concat(Array.from(object.attributes)); if (Composite.ATTRIBUTE_VALUE in selector) attributes.push(Composite.ATTRIBUTE_VALUE); attributes = attributes.filter((value, index, array) => {return array.indexOf(value) === index;}); attributes.forEach((attribute, index, array) => {if (attribute.match(Composite.PATTERN_ATTRIBUTE_ACCEPT) && !attribute.match(Composite.PATTERN_ATTRIBUTE_STATIC)) return; var value = object.attributes[attribute] || ""; if (!value.match(Composite.PATTERN_EXPRESSION_CONTAINS)) return; var context = serial + ":" + attribute; value = Expression.eval(context, value); value = String(value).encodeHtml(); value = value.replace(/"/g, "&quot;"); if (attribute.toLowerCase() == Composite.ATTRIBUTE_VALUE && Composite.ATTRIBUTE_VALUE in selector) selector.value = value; selector.setAttribute(attribute, value);});} if (selector.nodeName.match(Composite.PATTERN_SCRIPT)) {var type = (selector.getAttribute(Composite.ATTRIBUTE_TYPE) || "").trim(); if (type.match(Composite.PATTERN_COMPOSITE_SCRIPT)) {try {eval(selector.textContent);} catch (exception) {console.error(exception);}}} if (selector.childNodes && !selector.nodeName.match(Composite.PATTERN_ELEMENT_IGNORE)) {Array.from(selector.childNodes).forEach((node, index, array) => {if (!selector.contains(node)) return; if (node.nodeType != Node.TEXT_NODE) {var serial = node.ordinal(); var object = Composite.render.meta[serial]; if (object) if (object.hasOwnProperty("placeholder")) return;} Composite.render(node, lock.share());});}} finally {lock.release();}}; Composite.render.include = function(composite) {if (!(typeof composite == "string" || composite instanceof Element)) throw new TypeError("Invalid composite: " + typeof composite); var object = null; if (composite instanceof Element) {object = Composite.render.meta[composite.ordinal()]; if (!object) throw new TypeError("Unknown composite");} Composite.render.cache = Composite.render.cache || {}; var context = Composite.MODULES + "/" + (composite instanceof Element ? composite.id : composite); if (typeof Composite.render.cache[context + ".composite"] === "undefined") {Composite.render.cache[context + ".composite"] = null; var request = new XMLHttpRequest(); request.overrideMimeType("text/plain"); request.onreadystatechange = function() {if (request.readyState != 4 || request.status == "404") return; if (request.status != "200") throw new Error("HTTP status " + request.status + " for " + request.responseURL); var content = request.responseText.trim(); if (content) {Composite.render.cache[request.responseURL] = request.responseText; if (request.responseURL.match(/\.css$/)) {var head = document.querySelector("html head"); if (!head) throw new Error("No head element found"); var style = document.createElement("style"); style.setAttribute("type", "text/css"); style.textContent = content; head.appendChild(style);} else if (request.responseURL.match(/\.js$/)) {eval(content);} else if (request.responseURL.match(/\.html$/)) {object.attributes[Composite.ATTRIBUTE_IMPORT.name.toLowerCase()] = request.responseURL;}}}; request.open("GET", context + ".css", false); request.send(); request.open("GET", context + ".js", false); request.send(); if (object && !object.attributes.hasOwnProperty(Composite.ATTRIBUTE_IMPORT) && !object.attributes.hasOwnProperty(Composite.ATTRIBUTE_OUTPUT) && !composite.innerHTML.trim()) {request.open("GET", context + ".html", false); request.send();}}}; window.addEventListener("error", (event) => {Composite.fire(Composite.EVENT_ERROR, event);}); window.addEventListener("load", (event) => {(new MutationObserver((records) => {records.forEach((record) => {if (!Composite.render.meta) return; var serial = record.target.ordinal(); var object = Composite.render.meta[serial]; if (record.type == "characterData" && record.target.nodeType == Node.TEXT_NODE) {if (object && object.hasOwnProperty(Composite.ATTRIBUTE_VALUE) && String(object.value || "") != record.target.textContent) record.target.textContent = object.value || ""; return;} if (object && record.type == "attributes") {var attribute = (record.attributeName || "").toLowerCase().trim(); if (attribute.match(Composite.PATTERN_ATTRIBUTE_STATIC)) {var value = record.target.getAttribute(attribute); if (object.attributes[attribute] != value) record.target.setAttribute(attribute, object.attributes[attribute]);} else if (attribute.match(Composite.PATTERN_ATTRIBUTE_ACCEPT)) {record.target.removeAttribute(attribute);}} if (record.addedNodes) {record.addedNodes.forEach((node) => {if (node instanceof Element && !Composite.render.meta[node.ordinal()] && document.body.contains(node)) Composite.render(node);});} if (record.removedNodes) {record.removedNodes.forEach((node) => {var cleanup = function(node) {if (node.childNodes) {Array.from(node.childNodes).forEach((node) => {cleanup(node);});} var serial = node.ordinal(); var object = Composite.render.meta[serial]; if (object && object.attributes.hasOwnProperty(Composite.ATTRIBUTE_COMPOSITE)) {var meta = Composite.mount.lookup(node); if (meta && meta.model && Composite.models.includes(meta.model)) {Composite.models = Composite.models.filter(model => model != meta.model); if (meta.scope && typeof meta.scope.undock === "function") meta.scope.undock.call(null);}} delete Composite.render.meta[node.ordinal()];}; cleanup(node);});}});})).observe(document.body, {childList:true, subtree:true, attributes:true, characterData:true});});};
if (typeof Expression === "undefined") {Expression = {}; Expression.TYPE_TEXT = 1; Expression.TYPE_EXPRESSION = 2; Expression.TYPE_LITERAL = 3; Expression.TYPE_SCRIPT = 4; Expression.TYPE_KEYWORD = 5; Expression.TYPE_OTHER = 6; Expression.TYPE_METHOD = 7; Expression.TYPE_VALUE = 8; Expression.TYPE_LOGIC = 9; Expression.cache; Expression.lookup = function(context, expression) {try {if (typeof context === "string" && expression === undefined) {if (context.match(/^#[a-zA-Z]\w*$/)) return document.querySelector(context); if (context.match(/^(#[a-zA-Z]\w*)\.(.*)*$/)) {expression = context.match(/^(#[a-zA-Z]\w*)\.(.*)*$/); return Expression.lookup(document.querySelector(expression[1]), expression[2]);} if (context.indexOf(".") < 0) return eval(context); expression = context.match(/^(.*?)\.(.*)$/); return Expression.lookup(eval(expression[1]), expression[2]);} if (expression.indexOf(".") < 0) expression = [null, expression]; else expression = expression.match(/^(.*?)\.(.*)$/); var method = "get" + expression[1].capitalize(); if (typeof context[method] !== "function") method = "is" + expression[1].capitalize(); if (typeof context[method] === "function") {context = (context[method])(); if (expression.length > 2) return Expression.lookup(context, expression[2]); return context} context = (context[expression[1]]); if (expression.length > 2) return Expression.lookup(context, expression[2]); return context} catch (exception) {return undefined;}}; Expression.parse = function(expression) {if (expression === null || expression === undefined) expression = ""; else expression = expression.trim(); if (expression === "") return ""; var cascade = {words:[], text:[], expression:[], literal:[], script:[], keyword:[], other:[], value:[], method:[], logic:[]}; expression = expression.replace(/(^[\r\n]+)|([\r\n]+$)/g, ""); expression = expression.replace(/[\r\n]/g, " "); expression = expression.replace(/(\{\{)/g, "\n$1"); expression = expression.replace(/(\}\})/g, "$1\n"); if (expression.indexOf("\n") < 0) return "\"" + expression + "\""; expression = expression.replace(/(^\n+)|(\n+$)/g, ""); var collate = function(word) {if (word.type == Expression.TYPE_TEXT) cascade.text.push(word); else if (word.type == Expression.TYPE_EXPRESSION) cascade.expression.push(word); else if (word.type == Expression.TYPE_SCRIPT) cascade.script.push(word); else if (word.type == Expression.TYPE_LITERAL) cascade.literal.push(word); else if (word.type == Expression.TYPE_KEYWORD) cascade.keyword.push(word); else if (word.type == Expression.TYPE_OTHER) cascade.other.push(word); else if (word.type == Expression.TYPE_VALUE) cascade.value.push(word); else if (word.type == Expression.TYPE_METHOD) cascade.method.push(word); else if (word.type == Expression.TYPE_LOGIC) cascade.logic.push(word);}; expression.split(/\n/).forEach((entry, index, array) => {var object = {type:Expression.TYPE_TEXT, data:entry}; if (entry.match(/^\{\{.*\}\}$/)) {object.data = object.data.substring(2, object.data.length -2); object.type = Expression.TYPE_EXPRESSION;} else object.data = "\"" + object.data.replace(/\\/, "\\\\").replace(/"/, "\\\"") + "\""; collate(object); cascade.words.push(object);}); cascade.expression.forEach((entry, index, array) => {var text = entry.data; text = text.replace(/(^|[^\\])((?:\\{2})*\\[\'])/g, "$1\n$2\n"); text = text.replace(/(^|[^\\])((?:\\{2})*\\[\"])/g, "$1\r$2\r"); var words = []; var pattern = /(^.*?)(([\'\"]).*?(\3|$))/m; while (text.match(pattern)) {text = text.replace(pattern, (match, script, literal) => {script = script.replace(/\n/g, "\'"); script = script.replace(/\r/g, "\""); script = {type:Expression.TYPE_SCRIPT, data:script}; collate(script); words.push(script); literal = literal.replace(/\n/g, "\'"); literal = literal.replace(/\r/g, "\""); literal = {type:Expression.TYPE_LITERAL, data:literal}; collate(literal); words.push(literal); return "";});} if (text.length > 0) {text = text.replace(/\n/g, "\'"); text = text.replace(/\r/g, "\""); text = {type:Expression.TYPE_SCRIPT, data:text}; collate(text); words.push(text);} entry.data = words;}); var keywords = ["and", "&&", "or", "||", "not", "!", "eq", "==", "ne", "!=", "lt", "<", "gt", ">", "le", "<=", "ge", ">=", "empty", "!", "div", "/", "mod", "%"]; cascade.script.forEach((entry, index, array) => {var text = entry.data; for (var loop = 0; loop < keywords.length; loop += 2) {var pattern = new RegExp("(^|[^\\w\\.])(" + keywords[loop] + ")(?=[^\\w\\.]|$)", "ig"); text = text.replace(pattern, "$1\n\r" + keywords[loop +1] + "\n");} text = text.replace(/(^|[^\w\.])(true|false|null|instanceof|typeof|undefined|new)(?=[^\w\.]|$)/ig, (match, script, keyword) => {return script + "\n\r" + keyword.toLowerCase() + "\n";}); var words = []; text.split(/\n/).forEach((entry, index, array) => {var object = {type:Expression.TYPE_OTHER, data:entry}; if (entry.match(/^\r/)) {object.data = entry.substring(1); object.type = Expression.TYPE_KEYWORD;} collate(object); words.push(object);}); entry.data = words;}); cascade.other.forEach((entry, index, array) => {var text = entry.data; text = text.replace(/(^|[^\w\.])(#{0,1}[a-zA-Z](?:[\w\.]*[\w])*(?=(?:[^\w\(\.]|$)))/g, "$1\n\r\r$2\n"); text = text.replace(/(^|[^\w\.])(#{0,1}[a-zA-Z](?:[\w\.]*[\w])*)(?=\()/g, "$1\n\r$2\n"); var words = []; text.split(/\n/).forEach((entry, index, array) => {var object = {type:Expression.TYPE_LOGIC, data:entry}; if (entry.match(/^\r\r/)) {object.data = "Expression.lookup(\"" + entry.substring(2) + "\")"; object.type = Expression.TYPE_VALUE;} else if (entry.match(/^\r[^\r]/)) {object.data = entry.substring(1); if (object.data.match(/^#[a-zA-Z]/)) object.data = "Expression.lookup(\"" + object.data + "\")"; object.type = Expression.TYPE_METHOD;} collate(object); words.push(object);}); entry.data = words;}); var words = []; var merge = function(word) {if (Array.isArray(word)) word.forEach((entry, index, array) => {merge(entry);}); else if (Array.isArray(word.data)) word.data.forEach((entry, index, array) => {merge(entry);}); else if (typeof word.data === "string") if (word.data && word.data.length) words.push(word); else merge(word.data);}; merge(cascade.words); var script = ""; words.forEach((word, index, array) => {if (word.type == Expression.TYPE_TEXT) script += "\n" + word.data + "\r"; else if (word.type == Expression.TYPE_KEYWORD) script += " " + word.data + " "; else if (word.type == Expression.TYPE_LITERAL || word.type == Expression.TYPE_VALUE || word.type == Expression.TYPE_METHOD || word.type == Expression.TYPE_LOGIC) script += word.data;}); script = script.replace(/(^\n)|(\r$)/g, ""); if (script.match(/\r[^\n]*$/)) script += ")"; if (script.match(/^[^\r]*\n/)) script = "(" + script; script = script.replace(/(\n\r)+/g, " + "); script = script.replace(/\r/g, " + ("); script = script.replace(/\n/g, ") + "); script = script.replace(/(^\s*\+\s*)|(\s*\+\s*$)/, ""); return script;}; Expression.eval = function(variants) {Expression.cache = Expression.cache || []; var expression = null; if (arguments.length > 1) expression = arguments[1]; else if (arguments.length > 0) expression = arguments[0]; var serial = null; if (arguments.length > 1) serial = arguments[0]; var script = null; script = serial ? Expression.cache[serial] || null : null; if (!script) script = Expression.parse(expression); Expression.cache[serial] = script; try {return eval(script);} catch (exception) {exception.message += "\n\t" + script; console.error(exception); return exception.message;}};};
if (typeof Path === "undefined") {Path = {}; Path.PATTERN_PATH = /^(?:(?:#*(?:[a-z](?:(?:\w+)|(?:[\w\-]+\w+))*)*)(?:#+(?:[a-z](?:(?:\w+)|(?:[\w\-]+\w+))*)*)*)*$/; Path.PATTERN_URL = /^[a-z]+:\/.*?(#.*)*$/i; Path.PATTERN_PATH_FUNCTIONAL = /^#{3,}$/; Path.normalize = function(variants) {var path = null; var root = null; if (arguments.length == 1) {path = arguments[0];} else if (arguments.length >= 1) {root = arguments[0]; try {root = Path.normalize(root);} catch (exception) {throw new TypeError("Invalid root" + (String(root).trim() ? ": " + root : ""));} path = arguments[1];} if (root == null || root.match(/^(#+)*$/)) root = "#"; if (path == null) return null; if (typeof path === "string" && path.match(Path.PATTERN_URL)) path = path.replace(Path.PATTERN_URL, "$1"); if (typeof path !== "string" || !path.match(Path.PATTERN_PATH)) throw new TypeError("Invalid path" + (String(path).trim() ? ": " + path : "")); path = path.toLowerCase(); if (path.match(Path.PATTERN_PATH_FUNCTIONAL)) return "###"; if (path.length == 0) return root; if (path.match(/^[^#].*$/)) path = root + "#" + path; if (path.match(/^#{2}.*$/)) path = root + path; var pattern = /#[^#]+#{2}/; while (path.match(pattern)) path = path.replace(pattern, "#"); path = "#" + path.replace(/(^#+)|(#+)$/g, ""); return path;};};
if (typeof SiteMap === "undefined") {SiteMap = {}; SiteMap.location = "#"; SiteMap.ticks; SiteMap.paths; SiteMap.facets; SiteMap.acceptors; SiteMap.PATTERN_PATH = /^(#([a-z](?:(?:\w+)|(?:[\w\-]+\w+))*)*)+$/; SiteMap.PATTERN_PATH_FACETS = /^(#[a-z](?:(?:\w+)|(?:[\w\-]+\w+))*)(\s+(#[a-z](?:(?:\w+)|(?:[\w\-]+\w+))*)+)*$/; SiteMap.permit = function(path) {var acceptors = (SiteMap.acceptors || []).slice(); while (acceptors.length > 0) {var acceptor = acceptors.shift(); if (acceptor.pattern && !acceptor.pattern.test(path)) continue; acceptor = acceptor.action.call(null, path); if (acceptor !== true) {if (typeof acceptor === "string") acceptor = Path.normalize(acceptor); return acceptor;}} return true;}; SiteMap.locate = function(path, strict) {path = path || ""; try {path = Path.normalize(SiteMap.location, path);} catch (exception) {while (true) {path = path.replace(/(^[^#]+$)|(#[^#]*$)/, ""); try {path = Path.normalize(SiteMap.location, path);} catch (exception) {continue;} break;}} if (path.match(Path.PATTERN_PATH_FUNCTIONAL)) return path; var paths = Object.keys(SiteMap.paths || {}); if (!strict) paths = paths.concat(Object.keys(SiteMap.facets || {})); while (paths && path.length > 1) {if (paths.includes(path)) return path; path = Path.normalize(path + "##");} return "#";}; SiteMap.navigate = function(path) {window.location.hash = SiteMap.locate(path);}; SiteMap.lookup = function(path) {var paths = SiteMap.paths || {}; var facets = SiteMap.facets || {}; if (arguments.length <= 0) path = SiteMap.location; var canonical = function(meta) {if (!meta.facet) return meta.path; if (meta.path.endsWith("#")) return meta.path + meta.facet; return meta.path + "#" + meta.facet;}; var focus = function(focus) {window.setTimeout((focus) => {focus = focus ? document.querySelector("#" + focus) : focus; if (focus) {focus.scrollIntoView(true); focus.focus();}}, 0, (focus.facet || focus.face).replace(/^.*#/, ""));}; if (paths.hasOwnProperty(path)) return {path:path, face:path, facet:null, focus:function() {focus(this);}}; else if (facets.hasOwnProperty(path)) return {path:canonical(facets[path]), face:facets[path].path, facet:facets[path].facet, focus:function() {focus(this);}}; return null;}; SiteMap.accept = function(path) {path = (path || "").trim().toLowerCase(); if (!path.match(/^#.*$/)) return false; path = path.replace(/(#.*?)#*$/, "$1"); var location = SiteMap.lookup(Path.normalize(SiteMap.location)); if (!location) return false; var lookup = SiteMap.lookup(path); if (!lookup) return false; var partial = lookup.path; if (!partial.endsWith("#")) partial += "#"; if (lookup.facet && location.face != lookup.face && !location.path.startsWith(partial)) return false; if (!location.path.startsWith(partial) && location.face != lookup.face) return false; return true;}; SiteMap.customize = function(variants) {if (arguments.length > 1 && arguments[0] instanceof RegExp) {if (typeof arguments[1] !== "function") throw new TypeError("Invalid acceptor: " + typeof arguments[1]); SiteMap.acceptors = SiteMap.acceptors || []; SiteMap.acceptors.push({pattern:arguments[0], action:arguments[1]}); return;} if (arguments.length < 1 || typeof arguments[0] !== "object") throw new TypeError("Invalid map: " + typeof arguments[0]); var map = arguments[0]; var acceptors = (SiteMap.acceptors || []).slice(); if (arguments.length > 1) {if (typeof arguments[1] !== "function") throw new TypeError("Invalid permit: " + typeof arguments[1]); acceptors.push({pattern:null, action:arguments[1]});} var paths = {}; Object.keys(SiteMap.paths || {}).forEach((key) => {if (typeof key === "string" && key.match(SiteMap.PATTERN_PATH)) paths[key] = SiteMap.paths[key];}); var facets = {}; Object.keys(SiteMap.facets || {}).forEach((key) => {if (typeof key === "string" && key.match(SiteMap.PATTERN_PATH)) facets[key] = SiteMap.facets[key];}); Object.keys(map).forEach((key) => {if (typeof key !== "string" || !key.match(SiteMap.PATTERN_PATH)) return; var value = map[key]; if (value != null && !Array.isArray(value)) return; key = Path.normalize(key); paths[key] = paths[key] || []; value = value || []; value.forEach((facet) => {if (typeof facet !== "string") throw new TypeError("Invalid facet: " + typeof facet); facet = facet.toLowerCase().trim(); if (!facet.match(SiteMap.PATTERN_PATH_FACET)) throw new Error("Invalid facet: " + facet); if (!paths[key].includes(facet)) paths[key].push(facet); facets[Path.normalize(key, facet)] = {path:key, facet:facet};});}); SiteMap.acceptors = acceptors; SiteMap.paths = paths; SiteMap.facets = facets;}; Composite.customize((element) => {if (!(element instanceof Element) || !element.hasAttribute(Composite.ATTRIBUTE_COMPOSITE)) return; if (element.hasAttribute("static")) return; var path = "#" + Composite.mount.locate(element).model.replace(/\./g, "#").toLowerCase(); var script = null; if (element.hasAttribute(Composite.ATTRIBUTE_CONDITION)) {script = element.getAttribute(Composite.ATTRIBUTE_CONDITION).trim(); if (script.match(Composite.PATTERN_EXPRESSION_CONTAINS)) script = script.replace(Composite.PATTERN_EXPRESSION_CONTAINS, (match, offset, content) => {match = match.substring(2, match.length -2).trim(); return "{{SiteMap.accept(\"" + path + "\") and (" + match + ")}}";});} if (!script) script = (script || "") + "{{SiteMap.accept(\"" + path + "\")}}"; element.setAttribute(Composite.ATTRIBUTE_CONDITION, script);}); window.addEventListener("load", (event) => {Composite.render.include("common"); document.body.addEventListener("click", (event) => {if (event.target && event.target instanceof Element && event.target.hasAttribute("href")) {var target = SiteMap.lookup(event.target.getAttribute("href")); var source = SiteMap.lookup(Path.normalize(SiteMap.location)); if (source && target && source.face == target.face && source.facet == target.facet) target.focus();}}); if (Object.keys(SiteMap.paths || {}).length <= 0) {Composite.render(document.body); return;} var source = window.location.hash; var target = SiteMap.locate(source); if (!source && window.location.href.match(/[^#]#$/)) source = "#"; var event = document.createEvent("HTMLEvents"); event.initEvent("hashchange", false, true); event.newURL = target; if (source != target) SiteMap.navigate(target); else window.dispatchEvent(event);}); window.addEventListener("hashchange", (event) => {if (Object.keys(SiteMap.paths || {}).length <= 0) return; var source = Path.normalize(SiteMap.location); var locate = (event.newURL || "").replace(Path.PATTERN_URL, "$1"); var target = SiteMap.locate(locate); if (locate != target) {SiteMap.navigate(target); return;} SiteMap.ticks = (SiteMap.ticks || 0) +1; if (target.match(Path.PATTERN_PATH_FUNCTIONAL)) {var x = window.pageXOffset || document.documentElement.scrollLeft; var y = window.pageYOffset || document.documentElement.scrollTop; window.location.replace(source); window.scrollTo(x, y); return;} var forward = SiteMap.permit(target); if (forward !== true) {if (typeof forward == "string") SiteMap.navigate(forward); else SiteMap.navigate(target != "#" ? target + "##" : "#"); return;} SiteMap.location = target; source = SiteMap.lookup(source); target = SiteMap.lookup(target); if (source && target && (source.face != target.face || source.facet != target.facet)) target.focus(); if (source.face == target.face && SiteMap.ticks > 1) return; source = source.face; if (!source.endsWith("#")) source += "#"; target = target.face; if (!target.endsWith("#")) target += "#"; var render = "#"; if (source.startsWith(target)) render = target; else if (target.startsWith(source)) render = source; render = render.match(/((?:#[^#]+)|(?:^))#*$/)[0]; if (render && render[1]) Composite.render(render[1]); else Composite.render(document.body);});};
if (typeof Test === "undefined") {Test = {}; Test.activate = function() {if (typeof Test.activate.lock !== "undefined") return; Test.activate.lock = true; Test.output; Test.monitor; Test.stack; Test.queue; Test.task; Test.interval; Test.serial; Test.timeout; Test.autostart; Test.listeners; Test.PATTERN_EVENT = /^[a-z]+$/; Test.EVENT_FINISH = "finish"; Test.EVENT_INTERRUPT = "interrupt"; Test.EVENT_PERFORM = "perform"; Test.EVENT_RESPONSE = "response"; Test.EVENT_RESUME = "resume"; Test.EVENT_START = "start"; Test.EVENT_SUSPEND = "suspend"; Test.configure = function(options) {if (typeof options !== "object" && typeof options !== "function") return; if (typeof options.output === "object" || typeof options.output === "function") Test.output = options.output; if (typeof options.monitor === "object" || typeof options.monitor === "function") Test.monitor = options.monitor;}; Test.listen = function(event, callback) {if (typeof event !== "string") throw new TypeError("Invalid event: " + typeof event); if (typeof callback !== "function" && callback !== null && callback !== undefined) throw new TypeError("Invalid callback: " + typeof callback); if (!event.match(Test.PATTERN_EVENT)) throw new Error("Invalid event" + (event.trim() ? ": " + event : "")); event = event.toLowerCase(); Test.listeners = Test.listeners || []; if (!Array.isArray(Test.listeners[event])) Test.listeners[event] = []; Test.listeners[event].push(callback);}; Test.fire = function(event, status) {if (typeof Test.monitor === "object" && typeof Test.monitor[event] === "function") try {Test.monitor[event](status);} catch (error) {console.error(error);} event = (event || "").trim(); if (!Test.listeners || !event) return; var listeners = Test.listeners[event.toLowerCase()]; if (!Array.isArray(listeners)) return; listeners.forEach((callback, index, array) => {window.setTimeout(callback, 0, event, status);});}; Test.create = function(meta) {if (typeof meta !== "object" || typeof meta.test !== "function") return; if (typeof meta.ignore !== "undefined" && meta.ignore === true) return; Test.stack = Test.stack || []; if (Test.stack.indexOf(meta) >= 0) return; if (Test.serial == undefined) Test.serial = 0; meta.serial = ++Test.serial; Test.stack.push(meta);}; Test.start = function(auto) {if (Test.interval) return; if (auto && document.readyState == "loaded") {if (typeof Test.autostart === "undefined") {Test.autostart = true; window.addEventListener("load", () => {Test.start();});} return;} var numerical = function(number, text) {return number + " " + text + (number != 1 ? "s" : "");}; Test.output = Test.output || console; Test.monitor = Test.monitor || {start:function(status) {Test.output.log(new Date().toUTCString() + " Test is started" + ", " + numerical(status.queue.size, "task") + " in the queue");}, suspend:function(status) {Test.output.log(new Date().toUTCString() + " Test is suspended" + ", " + numerical(status.queue.length, "task") + " still outstanding");}, resume:function(status) {Test.output.log(new Date().toUTCString() + " Test is continued " + ", " + numerical(status.queue.size, "task") + " in the queue");}, interrupt:function(status) {Test.output.log(new Date().toUTCString() + " Test is interrupted" + "\n\t" + numerical(status.queue.size -status.queue.progress, "task") + " still outstanding" + "\n\t" + numerical(status.queue.faults, "fault") + " were detected" + "\n\ttotal time " + (new Date().getTime() -status.queue.timing) + " ms");}, perform:function(status) {}, response:function(status) {var timing = new Date().getTime() -status.task.timing; if (status.task.error) Test.output.error(new Date().toUTCString() + " Test task " + status.task.title + " " + status.task.error.message); else Test.output.log(new Date().toUTCString() + " Test task " + status.task.title + " was successful (" + timing + " ms)");}, finish:function(status) {Test.output.log(new Date().toUTCString() + " Test is finished" + "\n\t" + numerical(status.queue.size, "task") + " were performed" + "\n\t" + numerical(status.queue.faults, "fault") + " were detected" + "\n\ttotal time " + (new Date().getTime() -status.queue.timing) + " ms");}}; Test.stack = Test.stack || []; Test.queue = Test.queue || {timing:false, stack:[], size:0, lock:false, progress:0, faults:0}; if (Test.queue.stack.length == 0) {Test.queue.stack = Test.stack.slice(); Test.queue.size = Test.queue.stack.length; Test.queue.timing = new Date().getTime();} Test.timeout = window.setInterval(() => {if (!Test.task || !Test.task.running || !Test.queue.lock) return; if (!Test.task.timeout || Test.task.timeout > new Date().getTime()) return; Test.task.duration = new Date().getTime() -task.timing; Test.task.error = new Error("Timeout occurred, expected " + Test.task.timeout + " ms but was " + Test.task.duration + " ms"); Test.fire(Test.EVENT_RESPONSE, Test.status()); Test.queue.faults++; Test.queue.lock = false;}, 25); Test.interval = window.setInterval(() => {if (!Test.queue.lock && Test.queue.progress <= 0) Test.fire(Test.EVENT_START, Test.status()); if (Test.queue.lock) return; if (Test.queue.stack.length > 0) {Test.queue.lock = true; Test.queue.progress++; var meta = Test.queue.stack.shift(); var timeout = false; if ((meta.timeout || 0) > 0) timeout = new Date().getTime() +meta.timeout; Test.task = {title:null, meta:meta, running:true, timing:new Date().getTime(), timeout:timeout, duration:false, error:null}; Test.task.title = "#" + meta.serial; if (typeof meta.name === "string" && meta.name.trim().length > 0) Test.task.title += " " + meta.name.replace(/[\x00-\x20]+/g, " ").trim(); Test.fire(Test.EVENT_PERFORM, Test.status()); window.setTimeout(() => {var task = Test.task; try {task.meta.test();} catch (error) {task.error = error; if (!task.error.message || !task.error.message.trim()) task.error.message = "failed";} finally {if (task.meta.expected) {if (task.error) {if (typeof task.meta.expected === "function" && task.error instanceof(task.meta.expected)) task.error = null; if (typeof task.meta.expected === "object" && task.meta.expected instanceof(RegExp) && String(task.error).match(task.meta.expected)) task.error = null;} else task.error = Error("Assert error expected failed");} task.running = false; task.duration = new Date().getTime() -task.timing; if (task.timeout && task.timeout < new Date().getTime() && !task.error) {task.error = new Error("Timeout occurred, expected " + task.meta.timeout + " ms but was " + task.duration + " ms"); Test.fire(Test.EVENT_RESPONSE, Test.status()); Test.queue.faults++;} if (!task.error || !String(task.error.message).match(/^Timeout occurred/)) {if (task.error) Test.queue.faults++; Test.fire(Test.EVENT_RESPONSE, Test.status());} Test.queue.lock = false;}}, 0); return;} window.clearTimeout(Test.interval); Test.interval = null; Test.task = null; Test.fire(Test.EVENT_FINISH, Test.status());}, 25);}; Test.suspend = function() {if (!Test.interval) return; window.clearTimeout(Test.interval); Test.interval = null; while (Test.queue.lock) continue; Test.task = null; Test.fire(Test.EVENT_SUSPEND, Test.status());}; Test.resume = function() {if (!Test.interval) return; while (Test.queue.lock) continue; Test.task = null; if (Test.queue.stack.length <= 0) return; Test.start(); Test.fire(Test.EVENT_RESUME, Test.status());}; Test.interrupt = function() {if (!Test.interval) return; window.clearTimeout(Test.interval); Test.interval = null; while (Test.queue.lock) continue; Test.task = null; Test.queue.stack = []; Test.fire(Test.EVENT_INTERRUPT, Test.status());}; Test.status = function() {var task = null; if (Test.task) task = {title:Test.task.title, meta:Test.task.meta, running:Test.task.running, timing:Test.task.timing, timeout:Test.task.timeout, duration:Test.task.duration, error:Test.task.error}; var queue = null; if (Test.queue) queue = {timing:Test.queue.timing, size:Test.queue.size, length:Test.queue.stack.length, progress:Test.queue.progress, lock:Test.queue.lock, faults:Test.queue.faults}; return {task:task, queue:queue};}; if (typeof Assert === "undefined") {Assert = {}; Assert.create = function(arguments, size) {var assert = {message:null, values:[], error:function() {var words = Array.from(arguments); words.forEach((argument, index, array) => {array[index] = String(argument).replace(/\{(\d+)\}/g, (match, index) => {if (index > assert.values.length) return "[null]"; match = String(assert.values[index]); match = match.replace(/\s*[\r\n]+\s*/g, " "); return match;});}); var message = "expected {1} but was {2}"; if (assert.message != null) {assert.message = assert.message.trim(); if (assert.message) message = assert.message;} message = "{0} failed, " + message; message = message.replace(/\{(\d+)\}/g, (match, index) => {if (index > words.length) return "[null]"; match = String(words[index]); match = match.replace(/\s*[\r\n]+\s*/g, " "); return match;}); return new Error(message);}}; arguments = Array.from(arguments); if (arguments.length > size) assert.message = arguments.shift(); while (arguments.length > 0) assert.values.push(arguments.shift()); return assert;}; Assert.assertTrue = function(variants) {var assert = Assert.create(arguments, 1); if (assert.values[0] === true) return; throw assert.error("Assert.assertTrue", "true", "{0}");}; Assert.assertFalse = function(variants) {var assert = Assert.create(arguments, 1); if (assert.values[0] === false) return; throw assert.error("Assert.assertFalse", "false", "{0}");}; Assert.assertEquals = function(variants) {var assert = Assert.create(arguments, 2); if (assert.values[0] === assert.values[1]) return; throw assert.error("Assert.assertEquals", "{0}", "{1}");}; Assert.assertNotEquals = function(variants) {var assert = Assert.create(arguments, 2); if (assert.values[0] !== assert.values[1]) return; throw assert.error("Assert.assertNotEquals", "not {0}", "{1}");}; Assert.assertEqualsTo = function(selector, actual) {var element = document.querySelector(selector); var content = element.innerHTML.trim().replace(/\t/g, "    "); content = content.replace(/(\r\n)|(\n\r)|[\r\n]/gm, "\n"); content = content.replace(/(^\s+)|(\s+$)/gm, ""); actual = actual.trim(); actual = actual.replace(/\t/g, "    "); actual = actual.replace(/(\r\n)|(\n\r)|[\r\n]/gm, "\n"); actual = actual.replace(/(^\s+)|(\s+$)/gm, ""); Assert.assertEquals(content, actual);}; Assert.assertSame = function(variants) {var assert = Assert.create([], arguments, 2); if (assert.values[0] == assert.values[1]) return; throw assert.error("Assert.assertSame", "{0}", "{1}");}; Assert.assertNotSame = function(variants) {var assert = Assert.create(arguments, 2); if (assert.values[0] != assert.values[1]) return; throw assert.error("Assert.assertNotSame", "not {0}", "{1}");}; Assert.assertNull = function(variants) {var assert = Assert.create(arguments, 1); if (assert.values[0] === null) return; throw assert.error("Assert.assertNull", "null", "{0}");}; Assert.assertNotNull = function(variants) {var assert = Assert.create(arguments, 1); if (assert.values[0] !== null) return; throw assert.error("Assert.assertNotNull", "not null", "{0}");}; Assert.fail = function(message) {if (message) message = String(message).trim(); message = "Assert.fail" + (message ? ", " + message : ""); throw new Error(message);}}; if (typeof parent !== "undefined") {console.output = {log:"", warn:"", error:"", info:""}; console.output.clear = function() {console.output.log = ""; console.output.warn = ""; console.output.error = ""; console.output.info = "";}; console.forward = function(level, variants) {console.output[level] += Array.from(variants).join(", "); var invoke; if (parent) invoke = parent["on" + level.capitalize()]; if (invoke == null) invoke = console.forward[level]; invoke.apply(null, variants);}; console.forward.log = console.log; console.log = function(message) {console.forward("log", arguments);}; console.forward.warn = console.warn; console.warn = function(message) {console.forward("warn", arguments);}; console.forward.error = console.error; console.error = function(message) {console.forward("error", arguments);}; console.forward.info = console.info; console.info = function(message) {console.forward("info", arguments);}; if (typeof parent.onFinish === "function") Test.listen(Test.EVENT_FINISH, parent.onFinish); if (typeof parent.onInterrupt === "function") Test.listen(Test.EVENT_INTERRUPT, parent.onInterrupt); if (typeof parent.onPerform === "function") Test.listen(Test.EVENT_PERFORM, parent.onPerform); if (typeof parent.onResponse === "function") Test.listen(Test.EVENT_RESPONSE, parent.onResponse); if (typeof parent.onResume === "function") Test.listen(Test.EVENT_RESUME, parent.onResume); if (typeof parent.onStart === "function") Test.listen(Test.EVENT_START, parent.onStart); if (typeof parent.onSuspend === "function") Test.listen(Test.EVENT_SUSPEND, parent.onSuspend);}; if (Element.prototype.typeValue === undefined) {Element.prototype.typeValue = function(value, clear) {this.focus(); if (clear !== false) this.value = ""; var element = this; value = (value || "").split(""); value.forEach((digit, index, array) => {element.trigger("keydown"); element.value = (element.value || "") + digit; element.trigger("keyup");}); this.trigger("change");};}; if (Node.prototype.toPlainString === undefined) Node.prototype.toPlainString = function() {return (new XMLSerializer()).serializeToString(this);}; if (Element.prototype.toPlainString === undefined) Element.prototype.toPlainString = function() {return this.outerHTML;}; if (Object.prototype.toPlainString === undefined) Object.prototype.toPlainString = function() {return JSON.stringify(this);}; if (Element.prototype.trigger === undefined) Element.prototype.trigger = function(event, bubbles, cancel) {var trigger = document.createEvent("Event"); if (arguments.length < 2) bubbles = false; if (arguments.length < 3) cancel = true; trigger.initEvent(event, bubbles, cancel); this.dispatchEvent(trigger);};};};